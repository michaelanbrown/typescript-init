Basic TypeScript Types:

- Boolean
- Number
- String
    - Template Strings
- Array
- Enums (Enumerations)

----------------------------------

Declarations with let and const:

console.log(someString);
var someString = 'Hello World';

console.log(someString);
let someString = 'Hello World';
**Variables declared with let may not be used prior to declaration so this will throw an error

let someString = 'Hello World';
console.log(someString);

const someString = 'Hello World';
console.log(someString);

----------------------------------

Type Annotations and Type Inference

let x: string = 'I will forever be a string.';
**Now that the variable is declared a string, that is the only type it can ever be.
If trying to assign a different type (i.e. x = 42;) you will get a compiler error.

**Annotations are added by placing a colon after the variable, followed by the type you want the variable to be.
**You are not required to add type annotations to your declarations

let y = 'I will also forever be a string.';
**There is not type annotation but the variable will infer the type based on its initial value.
If trying to assign a different type (i.e. y = 42;) you will get a compiler error.

**Using annotations is more of a coding style because no matter what TypeScript will infer the type.
You should use them for code clarity such as when a variable is a function and you do not know what the outcome of the function will be initially. (i.e. let z = GetSomeValue();)
let z: number = GetSomeValue();

----------------------------------

Additional Types

- Void (absence of a type)
- Null
- Undefined
- Null and Undefined can be excluded from certain types
- Never (Values that will never occur - ex: functions that will never return because they are continuous or throw an error)
- Any (Can assign any type of value to it)

----------------------------------

Union Types

Can unionize as many type as you want

let someValue: number | string;
someValue = 42;
someValue = 'Hello World';
someValue = true will throw a complier error
**Can be a number or a string

----------------------------------

Using the --strictNullChecks Compiler Option

- By default null and undefined can be used with any type but this leads to lots of bugs, that can be avoided with using this option in TypeScript
- With this option set to true null and undefined are no longer valid values for any other type
- You must allow them by setting a union type to null and undefined
Assume we're using the strictNullChecks option:

let basicString: string;
basicString = null; (complier error)
basicString = undefined; (complier error)

let nullableString: string | null;
nullableString = null;
nullableString = undefined; (complier error)

let mysteryString = string | null | undefined;
mysteryString = null;
mysteryString = undefined;

----------------------------------

Arrays

- Arrays can be declared two diferent ways
- The type declared is the type being stored in the array
- If you want different types to be used in the array then declare the type as any
    - let anyArray: any[] = [42, true, 'banana'];
    - Should avoid using the any type declaration because it voids the benefits of using types
- Accessed and used much like JavaScript (methods in JS are available in TS)

1.
let strArray1: string[]= ['here', 'are', 'strings'];

2.
let strArray2: Array<string> = ['more', 'strings', 'here'];

----------------------------------

Controlling Program Flow

- For loop (similar to JS)
- While loops (similar to JS)
- Switch (similar to JS)

----------------------------------

Understanding Control Flow Type Analysis

- When declaring a function, parameters and the return should have type declarations
function ExampleFunction(title: string) : string | number {
    code
}

----------------------------------

--noImplicitAny Compiler Option

- Without type annotations the function parameters are implicitly assigned the any type which turns off type checking for that variable or parameter
- If you want to avoid accidentally using the any type then you can usee the --noImplicitAny compiler option (this will throw an error)
    - You can still explicitly use the any type, but cannot implicitly use it
