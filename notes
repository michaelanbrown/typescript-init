Basic TypeScript Types:

- Boolean
- Number
- String
    - Template Strings
- Array
- Enums (Enumerations)

----------------------------------

Declarations with let and const:

console.log(someString);
var someString = 'Hello World';

console.log(someString);
let someString = 'Hello World';
**Variables declared with let may not be used prior to declaration so this will throw an error

let someString = 'Hello World';
console.log(someString);

const someString = 'Hello World';
console.log(someString);

----------------------------------

Type Annotations and Type Inference

let x: string = 'I will forever be a string.';
**Now that the variable is declared a string, that is the only type it can ever be.
If trying to assign a different type (i.e. x = 42;) you will get a compiler error.

**Annotations are added by placing a colon after the variable, followed by the type you want the variable to be.
**You are not required to add type annotations to your declarations

let y = 'I will also forever be a string.';
**There is not type annotation but the variable will infer the type based on its initial value.
If trying to assign a different type (i.e. y = 42;) you will get a compiler error.

**Using annotations is more of a coding style because no matter what TypeScript will infer the type.
You should use them for code clarity such as when a variable is a function and you do not know what the outcome of the function will be initially. (i.e. let z = GetSomeValue();)
let z: number = GetSomeValue();

----------------------------------

Additional Types

- Void (absence of a type)
- Null
- Undefined
- Null and Undefined can be excluded from certain types
- Never (Values that will never occur - ex: functions that will never return because they are continuous or throw an error)
- Any (Can assign any type of value to it)

----------------------------------

Union Types

Can unionize as many type as you want

let someValue: number | string;
someValue = 42;
someValue = 'Hello World';
someValue = true will throw a complier error
**Can be a number or a string

----------------------------------

Using the --strictNullChecks Compiler Option

- By default null and undefined can be used with any type but this leads to lots of bugs, that can be avoided with using this option in TypeScript
- With this option set to true null and undefined are no longer valid values for any other type
- You must allow them by setting a union type to null and undefined
Assume we're using the strictNullChecks option:

let basicString: string;
basicString = null; (complier error)
basicString = undefined; (complier error)

let nullableString: string | null;
nullableString = null;
nullableString = undefined; (complier error)

let mysteryString = string | null | undefined;
mysteryString = null;
mysteryString = undefined;

----------------------------------

Arrays

- Arrays can be declared two diferent ways
- The type declared is the type being stored in the array
- If you want different types to be used in the array then declare the type as any
    - let anyArray: any[] = [42, true, 'banana'];
    - Should avoid using the any type declaration because it voids the benefits of using types
- Accessed and used much like JavaScript (methods in JS are available in TS)

1.
let strArray1: string[]= ['here', 'are', 'strings'];

2.
let strArray2: Array<string> = ['more', 'strings', 'here'];

----------------------------------

Controlling Program Flow

- For loop (similar to JS)
- While loops (similar to JS)
- Switch (similar to JS)

----------------------------------

Understanding Control Flow Type Analysis

- When declaring a function, parameters and the return should have type declarations
function ExampleFunction(title: string) : string | number {
    code
}

----------------------------------

--noImplicitAny Compiler Option

- Without type annotations the function parameters are implicitly assigned the any type which turns off type checking for that variable or parameter
- If you want to avoid accidentally using the any type then you can usee the --noImplicitAny compiler option (this will throw an error)
    - You can still explicitly use the any type, but cannot implicitly use it

- Compilers will use the any type for parameters as it cannot accurately predict the type of parameters

----------------------------------

Optional and Default Parameters

- In JS all function parameters are optional, but in TS all parameters are required
Optional:
    - But can mark a parameter as optional using the ?
    - Optional parameters must be last when declaring parameters
      function CreateCustomer(name: string, age?: number) {}
Default:
    - Default parameters let you specifiy a default value to use for optional or required parameters
    - Default parameters are treated as optional if they appear after all other parameters
    Can be a literal value or a function expression
      function GetBookByTitle(title: string = 'The C Programming Language') {} OR
      function GetBookByTitle(title: string = GetMostPopularBook()) {}
Rest Parameters:
    - Rest parameters give you a mechanism for passing a variable number of additional parameters after those specifically required in the function definition
    - Think of them as the rest of the parameters the function expects
    - Rest parameters are denoted with an ellipsis (...) prefix on the parameter name
      function GetBooksReadForCust(name: string, ...bookIds: number[]) {}
      let books = GetBooksReadForCust('Leigh', 2, 5);
        - bookIds is declared as a number array
        - The number array will contain 2 and 5
      let books = GetBooksReadForCust('Daniel', 2, 5, 12, 42);
        - The number array will contain 2, 5, 12, and 42

----------------------------------

Arrow Functions
- let squareit = x => x * x
    let result = squareit(4); //16
- let adder = (a, b) => a + b;
    let sum = adder(2, 3); //5
- let greeting = () => console.log ('Hello World!');
    greeting(); //Hello World!

- let scores: number[] = [70, 125, 85, 110];
    let highScores: number[];
    highScores = scores.filter((element, index, array) => {
        if (element > 100) {
            return true;
        }
    });